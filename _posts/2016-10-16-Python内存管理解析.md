---
layout: post
title:  "Python内存管理分析"
date:   2016-10-06
excerpt: "Python内存管理分析"
tag:
- Python
- 内存
- 管理
comments: true
---

## 1. Python的内存管理构成

Python的内存由block、pool、arena组成。

### 1.1 Block 
block有固定的size，是每次请求内存的时候拿到的具体内存，8字节对齐的，所以有8，16，24，32 。。。等大小。当某次需要28个字节的时候，实际上会得到一块32字节的block。
block在Python的源码中是没有对应的数据结构的，它其实体现成了Pool的一个属性。

### 1.2 Pool
pool是固定size的block的集合，举个例子要么是32字节block的pool, 要么是64字节block的pool, 以此类推。 pool的大小也是固定的，是内存页的大小4KB。
pool主要由pool_header这个struct，以及他拥有的内存构成。注意：pool_header和他拥有的内存是一起存在的，这意味着什么呢？一旦一个pool被new了出来，不仅立即拥有了pool_header，也立即拥有了pool管理的内存块。这是与后面arena非常不同的一点。
来简单的看一下pool_header这个struct
{% highlight c %}
struct pool_header {
    union { block *_padding;
            uint count; } ref;      /* number of allocated blocks    */
    block *freeblock;               /* pool's free list head         */
    struct pool_header *nextpool;   /* next pool of this size class  */
    struct pool_header *prevpool;   /* previous pool       ""        */
    uint arenaindex;                /* index into arenas of base adr */
    uint szidx;                     /* block size class index        *
    uint nextoffset;                /* bytes to virgin block         */
    uint maxnextoffset;             /* largest valid nextoffset      */
 };
{% endhighlight %}
大部分从注释都可以看出来具体是做什么用的，上文我提到的block size其实体现成了一个pool的属性，也就是szidx, 0就是8字节，1就是16字节，以此类推。freeblock指向了下一块可用block的起始地址。
我个人觉得Python在处理freeblock这个地方写法非常trick。一考虑到分配内存，我们很容易就会想到这样的场景：分配了N块block内存后，有某块或者某几块要被释放了，这个时候为了重复利用这些被释放了的block, 我们通常会维护一个block的列表，把这些block插入到这个列表中，那么下次分配的时候也就可以顺利分配。其实Python源码中的freeblock就是做这个事情的，不过它仅用了一个实际上uchar* 的指针就完成了整个列表，我们来看它是怎么做的。

 1. freeblock在初始化的时候指向了一块可用的block，*freeblock就应该是block的实际内容，被初始化成了NULL.
 2. 当有一块block A被释放的时候， 首先让这个block的首字节变为freeblock的地址，（地址实际上也就是一个数字嘛）
 3. 再让freeblock指向这块block A。
 

形成了如下的结构：

![freeblock](http://pic.yupoo.com/fayewu_v/FUjejaqH/MKgSe.png)


----------


freelock是block *, 其实看代码就能发现本质就是uchar *，freelock指向的内容是第一块空闲的block，也就是一个具体的内存了，这块内存的内容也可以看作是一个地址，为NULL。也就是说*freelock = = NULL（没办法，一切都是16进制，理解成地址／内容都是可以的。）
当一块block被释放后，首先让这块内存的第一字节的内容（也可以理解成地址）变为原来第一块空闲block的地址，然后freelock指向这块内存。最终就变为*freelock指向了下一块block的地址。
Python就这样用了一个非常trick的方式，仅仅用freelock这个uchar *的指针实现了链表结构。

一个pool有以下三种状态：

 1. used
    说明这个pool中有一个或多个block正在被占用，这种状态的pool会被一个全局的usedpools管理，后面会详细提到。

 2. empty
    这个pool的全部block都处于空闲状态。pool_header中的next_pool负责连接这些empty pool，而arena_object中的freepools是链表头，这样每个arena都拥有了自己的一条empty pools链表。
 3. full

下面来说一下这个usedpools的实现，这个实现就更trick了，好长时间不写C代码了，还费了点劲才理解。
来看usedpools的定义(我这里只截取了部分，)：
{% highlight c %}
#define PTA(x)  ((poolp )((uchar *)&(usedpools[2*(x)]) - 2*size(block *)
#define PT(x)   PTA(x), PTA(x)
static poolp usedpools[2 * ((NB_SMALL_SIZE_CLASSES + 7) / 8) * 8] = {        
    PT(0), PT(1), PT(2), PT(3), PT(4), PT(5), PT(6), PT(7)
#if NB_SMALL_SIZE_CLASSES > 8
    , PT(8), PT(9), PT(10), PT(11), PT(12), PT(13), PT(14), PT(15)
......
}
{% endhighlight %}
poolp即为struct pool_header *。usedpools是一个pool_header ＊的集合，每个元素的大小也就是8个字节（指针的大小），每个元素指向的地址是一个pool_header。看一下这个PTA(X), 以PTX(1)为🌰, block * 的大小为8个字节， &usedpool[2 * 1] - 2 *sizeof(block *) 这个地址其实代表了usedpools[0]本身的地址。也就是说usedpool[2]存放的是其实是usedpool[0]的地址。为什么说他trick呢？我们看下struct pool_header这个结构，会发现这个结构开头block ref, block *freepool分别花了一个字节，总共两个字节。接下来就是nextpool指针，也就是说struct pool_header的nextpool的地址其实是struct pool_header起始地址偏移两个字节的位置。
现在我们能看出来了，usedpool[2]指向了usedpool[0], 而usedpool[2]->nextpool正是usedpool[0]后偏移了两个字节， 也就是说对于i，在初始化的时候，它的nextpool指向了它本身。依次类推，prepool指向了和它X值一样的那个元素。也就是说只用了两个指针就实现了一个双链表。。。

于是有了如下需要某个size内存的block的分配代码：
{% highlight c %}
size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;
pool = usedpools[size + size];
if (pool != pool->nextpool) {
    .....
}
{% endhighlight %}
如果pool不等于pool->nextpool, 说明不是双链表不为空。有空闲的block可以被分配。
 
### 1.3 arena

arena就是pool的集合，也有固定的大小: 256KB, 也就是说一个arena含有64个pool。arena在Python的源码中有对应的数据结构，arena_object和它管理的内存。前面其实也有提到，和pool不同的是，arena_object和它管理的内存不是一起被分配到的，也就是说当分配了一个新的arena的时候，arena_object被分配了，而它管理的内存还是NULL。这个时候的arena被成为“未可用”状态，而当它管理的内存被分配了，arena就进入了“可用”状态。
众多的arena被三个结构所管理：

 1. arenas
    arenas是一个数组，实际上，从Python的全局内存管理来看，arenas组成了内存管理的主体结构部分。所有的arena都逃不过arenas的掌控。

 2. unused_arena_objects
    上述中“未可用”状态的arena集合，新申请好的arena_object都会先进入这个集合中。
 3. used_arena_objects
    上述中“可用”状态的arena集合。

来看一下arena_object的代码结构：
{% highlight c %}
/* Record keeping for arenas. */
struct arena_object {
    uptr address;
    /* Pool-aligned pointer to the next pool to be carved off. */
    block* pool_address;
    
    /* The number of available pools in the arena:  free pools + never-
    * allocated pools.
    */
    uint nfreepools;
    struct pool_header* freepools;
    struct arena_object* nextarena;
    struct arena_object* prevarena;
};
{% endhighlight %}
注意unused_arena_objects, used_arena_objects中的arena正是通过最后这两个arena指针进行连接的。

##2. Python的内存管理图

有了section 1的介绍，是时候祭出来Python内存管理这张大图了
![内存管理图] (http://pic.yupoo.com/fayewu_v/FVGPgZe9/lOwtP.png)


##3. 一张图看懂PyObject_Malloc做了什么

![内存分配](http://pic.yupoo.com/fayewu_v/FVGDWcqE/1M1HG.png)


 
